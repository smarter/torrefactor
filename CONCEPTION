* Organisation globale:
...

* IO synchrone vs asynchrone:
  Choix de java.io et du modèle "une connexion par thread" plutôt que
de java.nio et d'un seul thread dispatchant les messages car l'API de
java.nio est bien plus complexe[0] et semble être moins performante
que java.io[1], contrairement à ce qu'on pourraît croire.

* Écriture sur le disque:
  Utilisation de MappedByteBuffer qui équivaut à la fonction "mmap" en
C qui permet d'utiliser de la mémoire virtuelle pour écrire dans des
fichiers. Ceci laisse au système d'exploitation le choix du moment ou
l'écriture sur le disque doit être réellement faite. Par rapport à la
méthode de l'implémentation proposée, cette méthode présente
l'avantage de ne pas à avoir atteindre qu'une pièce soit totalement
réceptionnée avant de l'écrire sur le disque. Ceci permet d'éviter des
pertes importantes de données lors de la fermeture, étant donné que
beaucoup de blocs risquent de n'être que partiellement téléchargés.
  La seule contrainte est la taille maximale de mémoire virtuelle
allouée en même temps qui est limité à 4 Go sur les systèmes 32 bits.

* Gestion des blocks dans les pièces.
  IntervalMap est une classe créée pour gérer l'ajout, la suppression
et permettant de trouver l'intervale dans laquelle un point est. Elle
est implémentée à l'aide de java.util.TreeMap qui est un arbre
rouge-noir[2] dont les clés sont les débuts d'intervales et les
valeurs les fins d'intervales. Ceci permet l'ajout et la suppression
d'intervales en O(n*log(n)) et la recherche de l'intervale
correspondant dans laquelle un point est en O(log(n)).
  SawToothIntervalMap est utilisée pour gérer les blocks dont l'ajout
est temporaire, c'est à dire les requêtes "piece", qui peuvent ne pas
réussir(on ne peut les ignorer sans risquer de demander les même
blocks à différentes pièces). On ne peut simplement utiliser
IntervalMap car la suppression d'intervale est en O(n*log(n)) et donc
coûteuse à réaliser à chaque requête.

* Tracker UDP:
  Implémentation de la BEP 15[3] dans la classe UdpTracker.

* Plusieurs fichiers par torrent:
  Comme décrit dans la BEP 3[4] et sur wiki.theory.org[5]

* Support DHT:
  DHT(pour Distributed Hash Table) est une extension du protocole
BitTorrent. Elle permet l'échanges de nouveaux peers entre peers sans
passer par un tracker, rendant ainsi le protocole totalement
peer-to-peer. Elle est spécifiée dans la BEP 5[6] et est basée sur
Kademlia[7][8].
  Dans notre client, elle est implémentée de la manière suivante:
- Node représente un "node" DHT, c'est à dire un peer auquel on peut
envoyer des requêtes DHT sur un port spécifique.
- Bucket contient 8 nodes DHT et supprime les anciens lorsque de
nouveaux sont ajoutés si les anciens sont inaccessibles.
- NodeConnector gère la réception et l'envoi de messages DHT.
- NodeManager est un singleton qui gère la Map <info_hash, info du
peer> de notre node DHT, contient les Buckets de node(le bucket dans
lequel un node va dépend de son préfixe comment avec notre id) et
implémente les algorithmes de recherche de noeuds décrit dans [8].
- KRPCMessage représente un message du protocole DHT.

[0]: http://tutorials.jenkov.com/java-nio/index.html
[1]: http://paultyma.blogspot.com/2008/03/writing-java-multithreaded-servers.html
[2]: http://en.wikipedia.org/wiki/Red_black_tree
[3]: http://bittorrent.org/beps/bep_0015.html
[4]: http://bittorrent.org/beps/bep_0003.html
[5]: http://wiki.theory.org/BitTorrentSpecification#Info_in_Multiple_File_Mode
[6]: http://bittorrent.org/beps/bep_0005.html
[7]: http://www.cs.rice.edu/Conferences/IPTPS02/109.pdf
[8]: http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html
